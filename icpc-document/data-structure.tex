\section{data-structure}

\subsection{Segment Tree}

\begin{small}
\begin{markdown}
- `void update(int k, T x)`
    - $k$ 番目の要素を $x$ に更新する
    - 時間計算量: $O(\log n)$
- `T fold(int l, int r)`
    - 区間 $[l, r)$ の値を fold する
    - 時間計算量: $O(\log n)$
- `int find\_first(int l, F cond)`
    - `fold(l, r)` が条件 `cond` を満たすような最小の $r (> l)$ 返す．列の単調性を仮定する．そのような $r$ が存在しない場合は `-1` を返す
    - 時間計算量: $O(\log n)$
- `int find\_last(int r, F cond)`
    - `fold(l, r)` が条件 `cond` を満たすような最大の $l (< r)$ 返す．列の単調性を仮定する．そのような $l$ が存在しない場合は `-1` を返す
    - 時間計算量: $O(\log n)$

\end{markdown}

モノイドの渡し方
\begin{lstlisting}
struct Monoid {
    using T = int;  // 型
    static T id() { return 1e9; };  // 単位元
    static T op(T a, T b) { return min(a, b); }  // 二項演算 (結合的)
};
\end{lstlisting}
\end{small}

\begin{lstlisting}
template <typename M>
class SegmentTree {
    using T = typename M::T;

public:
    SegmentTree() = default;
    explicit SegmentTree(int n): SegmentTree(std::vector<T>(n, M::id())) {}
    explicit SegmentTree(const std::vector<T>& v) {
        size = 1;
        while (size < (int) v.size()) size <<= 1;
        node.resize(2 * size, M::id());
        std::copy(v.begin(), v.end(), node.begin() + size);
        for (int i = size - 1; i > 0; --i) node[i] = M::op(node[2 * i], node[2 * i + 1]);
    }

    T operator[](int k) const {
        return node[k + size];
    }

    void update(int k, const T& x) {
        k += size;
        node[k] = x;
        while (k >>= 1) node[k] = M::op(node[2 * k], node[2 * k + 1]);
    }

    T fold(int l, int r) const {
        T vl = M::id(), vr = M::id();
        for (l += size, r += size; l < r; l >>= 1, r >>= 1) {
            if (l & 1) vl = M::op(vl, node[l++]);
            if (r & 1) vr = M::op(node[--r], vr);
        }
        return M::op(vl, vr);
    }

    template <typename F>
    int find_first(int l, F cond) const {
        T vl = M::id();
        int r = size;
        for (l += size, r += size; l < r; l >>= 1, r >>= 1) {
            if (l & 1) {
                T nxt = M::op(vl, node[l]);
                if (cond(nxt)) {
                    while (l < size) {
                        nxt = M::op(vl, node[2 * l]);
                        if (cond(nxt)) l = 2 * l;
                        else vl = nxt, l = 2 * l + 1;
                    }
                    return l - size;
                }
                vl = nxt;
                ++l;
            }
        }
        return -1;
    }

    template <typename F>
    int find_last(int r, F cond) const {
        T vr = M::id();
        int l = 0;
        for (l += size, r += size; l < r; l >>= 1, r >>= 1) {
            if (r & 1) {
                --r;
                T nxt = M::op(node[r], vr);
                if (cond(nxt)) {
                    while (r < size) {
                        nxt = M::op(node[2 * r + 1], vr);
                        if (cond(nxt)) r = 2 * r + 1;
                        else vr = nxt, r = 2 * r;
                    }
                    return r - size;
                }
                vr = nxt;
            }
        }
        return -1;
    }

private:
    int size;
    std::vector<T> node;
};
\end{lstlisting}

\subsection{Segment Tree with Lazy Propagation}

\begin{small}
モノイドと作用の渡し方
\begin{lstlisting}
// 作用されるモノイド
struct M {
    using T = pair<ll, int>;  // 型
    static T id() { return {0, 1}; }  // 単位元
    static T op(T a, T b) {
        return {a.first + b.first, a.second + b.second};  // 二項演算 (結合的)
    }
};

// 作用するモノイド
struct O {
    using T = ll;  // 型
    static T id() { return 0; }  // 単位元
    static T op(T a, T b) {
        return a + b;  // 二項演算 (結合的)
    }
};

// 作用 (分配的)
M::T act(M::T a, O::T b) {
    return {a.first + a.second * b, a.second};
}

\end{lstlisting}

\end{small}

\begin{lstlisting}
template <typename M, typename O, typename M::T (*act)(typename M::T, typename O::T)>
class LazySegmentTree {
    using T = typename M::T;
    using E = typename O::T;

public:
    LazySegmentTree() = default;
    explicit LazySegmentTree(int n) : LazySegmentTree(std::vector<T>(n, M::id())) {}
    explicit LazySegmentTree(const std::vector<T>& v) {
        size = 1;
        while (size < (int) v.size()) size <<= 1;
        node.resize(2 * size, M::id());
        lazy.resize(2 * size, O::id());
        std::copy(v.begin(), v.end(), node.begin() + size);
        for (int i = size - 1; i > 0; --i) node[i] = M::op(node[2 * i], node[2 * i + 1]);
    }

    T operator[](int k) {
        return fold(k, k + 1);
    }

    void update(int l, int r, const E& x) { update(l, r, x, 1, 0, size); }

    T fold(int l, int r) { return fold(l, r, 1, 0, size); }

    template <typename F>
    int find_first(int l, F cond) {
        T v = M::id();
        return find_first(l, size, 1, 0, size, v, cond);
    }

    template <typename F>
    int find_last(int r, F cond) {
        T v = M::id();
        return find_last(0, r, 1, 0, size, v, cond);
    }

private:
    int size;
    std::vector<T> node;
    std::vector<E> lazy;

    void push(int k) {
        if (lazy[k] == O::id()) return;
        if (k < size) {
            lazy[2 * k] = O::op(lazy[2 * k], lazy[k]);
            lazy[2 * k + 1] = O::op(lazy[2 * k + 1], lazy[k]);
        }
        node[k] = act(node[k], lazy[k]);
        lazy[k] = O::id();
    }

    void update(int a, int b, const E& x, int k, int l, int r) {
        push(k);
        if (r <= a || b <= l) return;
        if (a <= l && r <= b) {
            lazy[k] = O::op(lazy[k], x);
            push(k);
            return;
        }
        int m = (l + r) / 2;
        update(a, b, x, 2 * k, l, m);
        update(a, b, x, 2 * k + 1, m, r);
        node[k] = M::op(node[2 * k], node[2 * k + 1]);
    }

    T fold(int a, int b, int k, int l, int r) {
        push(k);
        if (r <= a || b <= l) return M::id();
        if (a <= l && r <= b) return node[k];
        int m = (l + r) / 2;
        return M::op(fold(a, b, 2 * k, l, m),
                     fold(a, b, 2 * k + 1, m, r));
    }

    template <typename F>
    int find_first(int a, int b, int k, int l, int r, T& v, F cond) {
        push(k);
        if (r <= a) return -1;
        if (b <= l) return l;
        if (a <= l && r <= b && !cond(M::op(v, node[k]))) {
            v = M::op(v, node[k]);
            return -1;
        }
        if (r - l == 1) return r;
        int m = (l + r) / 2;
        int res = find_first(a, b, 2 * k, l, m, v, cond);
        if (res != -1) return res;
        return find_first(a, b, 2 * k + 1, m, r, v, cond);
    }

    template <typename F>
    int find_last(int a, int b, int k, int l, int r, T& v, F cond) {
        push(k);
        if (b <= l) return -1;
        if (r <= a) return r;
        if (a <= l && r <= b && !cond(M::op(node[k], v))) {
            v = M::op(node[k], v);
            return -1;
        }
        if (r - l == 1) return l;
        int m = (l + r) / 2;
        int res = find_last(a, b, 2 * k + 1, m, r, v, cond);
        if (res != -1) return res;
        return find_last(a, b, 2 * k, l, m, v, cond);
    }
};
\end{lstlisting}

\subsection{Fenwick Tree}

\begin{small}
\begin{markdown}
- `T prefix\_fold(int i)`
    - 区間 $[0, i)$ の値を fold する
    - 時間計算量: $O(\log n)$
- `void update(int i, T x)`
    - $i$ 番目の要素を $x$ と演算した値に更新する
    - 時間計算量: $O(\log n)$
- `int lower\_bound(T x)`
    - `prefix\_fold(i) \geq x` となる最初の $i$ を返す．そのような $i$ が存在しない場合は $n$ を返す．`cmp` を指定しない場合は `<` で比較される．列の単調性を仮定する．
    - 時間計算量: $O(\log n)$
\end{markdown}
\end{small}

\begin{lstlisting}
template <typename M>
class FenwickTree {
    using T = typename M::T;

public:
    FenwickTree() = default;
    explicit FenwickTree(int n) : n(n), data(n + 1, M::id()) {}

    T prefix_fold(int i) const {
        T ret = M::id();
        for (; i > 0; i -= i & -i) ret = M::op(ret, data[i]);
        return ret;
    }

    void update(int i, const T& x) {
        for (++i; i <= n; i += i & -i) data[i] = M::op(data[i], x);
    }

    int lower_bound(const T& x) const {
        return lower_bound(x, std::less<>());
    }

    int lower_bound(const T& x) const {
        if (x <= M::id()) return 0;
        int k = 1;
        while (k * 2 <= n) k <<= 1;
        int i = 0;
        T v = M::id();
        for (; k > 0; k >>= 1) {
            if (i + k > n) continue;
            T nv = M::op(v, data[i + k]);
            if (nv < x) {
                v = nv;
                i += k;
            }
        }
        return i;
    }

private:
    int n;
    std::vector<T> data;
};
\end{lstlisting}

\subsection{Range Tree}

\begin{small}
\begin{markdown}
- `RangeTree(vector<tuple<int, Y, T>>> pts)`
    - `pts` の点から領域木を構築する．点は $(x, y, v)$ の形式で与えられる．
    - 時間計算量: $O(n\log n)$
- `T fold(X sx, X tx, Y sy, Y ty)`
    - 長方形領域 $[sx, tx) \times [sy, ty)$ 内の点に対する値の総和を計算する
    - 時間計算量: $O((\log n)^2)$
\end{markdown}
\end{small}

\begin{lstlisting}
template <typename X, typename Y, typename T>
class RangeTree {
public:
    RangeTree() = default;
    explicit RangeTree(const std::vector<std::tuple<X, Y, T>>& pts) {
        for (auto& [x, y, v] : pts) xs.push_back(x);
        std::sort(xs.begin(), xs.end());
        xs.erase(std::unique(xs.begin(), xs.end()), xs.end());

        int n = xs.size();
        size = 1;
        while (size < n) size <<= 1;
        node.resize(2 * size);
        sum.resize(2 * size);

        for (auto& [x, y, v] : pts) {
            int i = std::lower_bound(xs.begin(), xs.end(), x) - xs.begin();
            node[size + i].emplace_back(y, v);
        }

        for (int i = 0; i < n; ++i) {
            std::sort(node[size + i].begin(), node[size + i].end());
        }
        for (int i = size - 1; i > 0; --i) {
            std::merge(node[2*i].begin(), node[2*i].end(), node[2*i+1].begin(), node[2*i+1].end(), std::back_inserter(node[i]));
        }
        for (int i = 0; i < size + n; ++i) {
            sum[i].resize(node[i].size() + 1);
            for (int j = 0; j < (int) node[i].size(); ++j) {
                sum[i][j + 1] = sum[i][j] + node[i][j].second;
            }
        }
    }

    T fold(X sx, X tx, Y sy, Y ty) const {
        int l = std::lower_bound(xs.begin(), xs.end(), sx) - xs.begin();
        int r = std::lower_bound(xs.begin(), xs.end(), tx) - xs.begin();
        T ret = 0;
        auto cmp = [&](const std::pair<Y, T>& p, Y y) { return p.first < y; };
        for (l += size, r += size; l < r; l >>= 1, r >>= 1) {
            if (l & 1) {
                int hi = std::lower_bound(node[l].begin(), node[l].end(), ty, cmp) - node[l].begin();
                int lo = std::lower_bound(node[l].begin(), node[l].end(), sy, cmp) - node[l].begin();
                ret += sum[l][hi] - sum[l][lo];
                ++l;
            }
            if (r & 1) {
                --r;
                int hi = std::lower_bound(node[r].begin(), node[r].end(), ty, cmp) - node[r].begin();
                int lo = std::lower_bound(node[r].begin(), node[r].end(), sy, cmp) - node[r].begin();
                ret += sum[r][hi] - sum[r][lo];
            }
        }
        return ret;
    }


private:
    int size;
    std::vector<X> xs;
    std::vector<std::vector<std::pair<Y, T>>> node;
    std::vector<std::vector<T>> sum;
};

\end{lstlisting}

\subsection{Union Find}

\begin{lstlisting}
class UnionFind {
public:
    UnionFind() = default;
    explicit UnionFind(int n) : data(n, -1) {}

    int find(int x) {
        if (data[x] < 0) return x;
        return data[x] = find(data[x]);
    }

    void unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return;
        if (data[x] > data[y]) std::swap(x, y);
        data[x] += data[y];
        data[y] = x;
    }

    bool same(int x, int y) {
        return find(x) == find(y);
    }

    int size(int x) {
        return -data[find(x)];
    }

private:
    std::vector<int> data;
};
\end{lstlisting}

\subsection{Weighted Union Find}

\begin{small}
\begin{markdown}
- `int find(int x)`
    - $x$ が属する木の根を返す
    - 時間計算量: $\mathrm{amortized}\ O(\alpha(n))$
- `T weight(int x)`
    - 木の根に対する $x$ の重みを返す
    - 時間計算量: $\mathrm{amortized}\ O(\alpha(n))$
- `void unite(int x, int y, T w)`
    - $x$ が属する集合と $y$ が属する集合を $weight(y) - weight(x) = w$ となるように連結する
    - 時間計算量: $\mathrm{amortized}\ O(\alpha(n))$
- `bool same(int x, int y)`
    - $x$ と $y$ が同じ集合に属するかを判定する
    - 時間計算量: $\mathrm{amortized}\ O(\alpha(n))$
- `T diff(int x, int y)`
    - $x$ に対する $y$ の重み，すなわち $weight(y) - weight(x)$ を返す
    - 時間計算量: $\mathrm{amortized}\ O(\alpha(n))$
- `int size(int x)`
    - $x$ が属する集合の大きさを返す
    - 時間計算量: $\mathrm{amortized}\ O(\alpha(n))$
\end{markdown}
\end{small}

\begin{lstlisting}
template <typename T>
class WeightedUnionFind {
public:
    WeightedUnionFind() = default;
    explicit WeightedUnionFind(int n) : data(n, -1), ws(n) {}

    int find(int x) {
        if (data[x] < 0) return x;
        int r = find(data[x]);
        ws[x] += ws[data[x]];
        return data[x] = r;
    }

    T weight(int x) {
        find(x);
        return ws[x];
    }

    bool unite(int x, int y, T w) {
        w += weight(x);
        w -= weight(y);
        x = find(x);
        y = find(y);
        if (x == y) return false;
        if (data[x] > data[y]) {
            std::swap(x, y);
            w = -w;
        }
        data[x] += data[y];
        data[y] = x;
        ws[y] = w;
        return true;
    }

    bool same(int x, int y) {
        return find(x) == find(y);
    }

    T diff(int x, int y) {
        return weight(y) - weight(x);
    }

    int size(int x) {
        return -data[find(x)];
    }

private:
    std::vector<int> data;
    std::vector<T> ws;
};
\end{lstlisting}

\subsection{Convex Hull Trick}

\begin{small}
\begin{markdown}
1次関数の最小値．傾きは単調非増加

- `ConvexHullTrick(bool monotone\_query)`
    - 最小値クエリの $x$ が単調非減少ならば，`monotone\_query = true` とすれば計算量が改善する．デフォルトは `monotone\_query = false`
    - 時間計算量: $O(1)$
- `T add(T a, T b)`
    - 直線 $ax + b$ を $L$ に追加する
    - 時間計算量: $\mathrm{amortized}\ O(1)$
- `T get(T x)`
    - 与えられた $x$ に対し，$L$ の中で最小値を取る直線の値を求める
    - 時間計算量: `monotone\_query = true` なら $\mathrm{amortized}\ O(1)$, `false` なら $O(\log n)$
\end{markdown}
\end{small}

\begin{lstlisting}
template <typename T>
class ConvexHullTrick {
public:
    explicit ConvexHullTrick(bool monotone_query = false) : monotone_query(monotone_query) {}

    void add(T a, T b) {
        Line line(a, b);
        while (lines.size() >= 2 && check(*(lines.end() - 2), lines.back(), line)) {
            lines.pop_back();
        }
        lines.push_back(line);
    }

    T get(T x) {
        if (monotone_query) {
            while (lines.size() - head >= 2 && lines[head](x) > lines[head + 1](x)) {
                ++head;
            }
            return lines[head](x);
        } else {
            int lb = -1, ub = lines.size() - 1;
            while (ub - lb > 1) {
                int m = (lb + ub) / 2;
                if (lines[m](x) > lines[m + 1](x)) {
                    lb = m;
                } else {
                    ub = m;
                }
            }
            return lines[ub](x);
        }
    }

private:
    struct Line {
        T a, b;
        Line(T a, T b) : a(a), b(b) {}
        T operator()(T x) const { return a * x + b; }
    };

    std::vector<Line> lines;
    bool monotone_query;
    int head = 0;

    static bool check(Line l1, Line l2, Line l3) {
        if (l2.a == l3.a) return l2.b >= l3.b;
        return 1.0 * (l2.b - l1.b) / (l2.a - l1.a) <= 1.0 * (l3.b - l2.b) / (l3.a - l2.a);
    }
};
\end{lstlisting}